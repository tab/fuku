// Code generated by MockGen. DO NOT EDIT.
// Source: internal/app/runner/readiness.go
//
// Generated by this command:
//
//	mockgen -source=internal/app/runner/readiness.go -destination=internal/app/runner/readiness_mock.go -package=runner
//

// Package runner is a generated GoMock package.
package runner

import (
	context "context"
	config "fuku/internal/config"
	io "io"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockReadiness is a mock of Readiness interface.
type MockReadiness struct {
	ctrl     *gomock.Controller
	recorder *MockReadinessMockRecorder
	isgomock struct{}
}

// MockReadinessMockRecorder is the mock recorder for MockReadiness.
type MockReadinessMockRecorder struct {
	mock *MockReadiness
}

// NewMockReadiness creates a new mock instance.
func NewMockReadiness(ctrl *gomock.Controller) *MockReadiness {
	mock := &MockReadiness{ctrl: ctrl}
	mock.recorder = &MockReadinessMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReadiness) EXPECT() *MockReadinessMockRecorder {
	return m.recorder
}

// Check mocks base method.
func (m *MockReadiness) Check(ctx context.Context, name string, service *config.Service, process Process) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Check", ctx, name, service, process)
}

// Check indicates an expected call of Check.
func (mr *MockReadinessMockRecorder) Check(ctx, name, service, process any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockReadiness)(nil).Check), ctx, name, service, process)
}

// CheckHTTP mocks base method.
func (m *MockReadiness) CheckHTTP(ctx context.Context, url string, timeout, interval time.Duration, done <-chan struct{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckHTTP", ctx, url, timeout, interval, done)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckHTTP indicates an expected call of CheckHTTP.
func (mr *MockReadinessMockRecorder) CheckHTTP(ctx, url, timeout, interval, done any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckHTTP", reflect.TypeOf((*MockReadiness)(nil).CheckHTTP), ctx, url, timeout, interval, done)
}

// CheckLog mocks base method.
func (m *MockReadiness) CheckLog(ctx context.Context, pattern string, stdout, stderr *io.PipeReader, timeout time.Duration, done <-chan struct{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckLog", ctx, pattern, stdout, stderr, timeout, done)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckLog indicates an expected call of CheckLog.
func (mr *MockReadinessMockRecorder) CheckLog(ctx, pattern, stdout, stderr, timeout, done any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckLog", reflect.TypeOf((*MockReadiness)(nil).CheckLog), ctx, pattern, stdout, stderr, timeout, done)
}
